<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Major:MIDI → Virtual Piano 문자 악보 변환기</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
    }

    #output {
      white-space: pre-wrap;
      padding: 15px;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <h2>Major:MIDI → Virtual Piano 문자 악보 변환기</h2>
  <input type="file" id="midi-file" accept=".mid,.midi">
  <pre id="output">MIDI 파일을 선택하세요...</pre>

  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
  <script>
    const midiToVpKey = {
      36: "1", 37: "!", 38: "2", 39: "@", 40: "3",
      41: "4", 42: "$", 43: "5", 44: "%", 45: "6",
      46: "^", 47: "7", 48: "8", 49: "*", 50: "9",
      51: "(", 52: "0", 53: "q", 54: "Q", 55: "w",
      56: "W", 57: "e", 58: "E", 59: "r", 60: "t",
      61: "T", 62: "y", 63: "Y", 64: "u", 65: "i",
      66: "I", 67: "o", 68: "O", 69: "p", 70: "P",
      71: "a", 72: "s", 73: "S", 74: "d", 75: "D",
      76: "f", 77: "g", 78: "G", 79: "h", 80: "H",
      81: "j", 82: "J", 83: "k", 84: "l", 85: "L",
      86: "z", 87: "Z", 88: "x", 89: "c", 90: "C",
      91: "v", 92: "V", 93: "b", 94: "B", 95: "n", 96: "m"
    };

    const TIME_GAP_SCALE = 10;  // 시간 차이에 따른 공백 비율
    const MAX_LINE_WIDTH = 150; // 한 줄 최대 문자 길이

    document.getElementById('midi-file').addEventListener('change', async function () {
      const file = this.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async function (e) {
        const midi = new Midi(e.target.result);
        const events = [];

        // 모든 노트 수집
        midi.tracks.forEach(track => {
          track.notes.forEach(note => {
            const char = midiToVpKey[note.midi];
            if (char) events.push({ time: note.time, char });
          });
        });

        // 시간순 정렬
        events.sort((a, b) => a.time - b.time);

        // === 같은 시간대 노트 묶기 ===
        const grouped = [];
        let currentTime = null;
        let currentNotes = [];

        events.forEach(({ time, char }) => {
          if (currentTime === null) {
            currentTime = time;
            currentNotes = [char];
          } else if (Math.abs(time - currentTime) < 0.000001) {
            // 완전히 동일한 시간 → 같은 그룹에 추가
            currentNotes.push(char);
          } else {
            grouped.push({ time: currentTime, chars: currentNotes.sort().join('') });
            currentTime = time;
            currentNotes = [char];
          }
        });
        if (currentNotes.length) grouped.push({ time: currentTime, chars: currentNotes.sort().join('') });

        // === 출력 ===
        let outputHTML = '';
        let prevTime = 0;
        let lineWidth = 0;

        grouped.forEach(({ time, chars }) => {
          const gap = Math.round((time - prevTime) * TIME_GAP_SCALE);
          const totalWidth = gap + chars.length;

          // 줄 너비 초과 시 줄바꿈
          if (lineWidth + totalWidth > MAX_LINE_WIDTH) {
            outputHTML += '\n';
            lineWidth = 0;
          }

          outputHTML += '&nbsp;'.repeat(gap > 0 ? gap : 1) + chars;
          lineWidth += totalWidth;
          prevTime = time;
        });

        document.getElementById('output').innerHTML = outputHTML;
      };
      reader.readAsArrayBuffer(file);
    });
  </script>
</body>

</html>